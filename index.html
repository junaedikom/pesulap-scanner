<!doctype html>
<html lang="id">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Pesulap Scanner</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        :root{--bg:#0f172a;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;color-scheme:dark}
        body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; margin:0;background:linear-gradient(180deg,#021025 0%, #041428 100%);color:#e6eef6}
        .wrap{max-width:1000px;margin:28px auto;padding:18px}
        header{display:flex;align-items:center;gap:12px}
        h1{margin:0;font-size:20px}
        .controls{display:flex;gap:10px;flex-wrap:wrap;margin:12px 0}
        .btn{background:var(--accent);color:#021022;padding:8px 12px;border-radius:8px;border:0;cursor:pointer}
        .btn.secondary{background:#0a2740;color:#cfeefa}
        .card{background:rgba(255,255,255,0.03);padding:12px;border-radius:12px;margin-top:12px}
        #video-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: auto;
            border-radius: 8px;
            overflow: hidden;
        }
        #video {
            width: 100%;
            display: block;
        }
        .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;margin-top:10px}
        .thumb{position:relative;border-radius:8px;overflow:hidden;background:#061226}
        .thumb img{width:100%;height:100%;object-fit:cover;display:block}
        .thumb .meta{position:absolute;left:6px;bottom:6px;background:rgba(0,0,0,0.45);padding:4px 6px;border-radius:6px;font-size:12px}
        .actions{display:flex;gap:8px;margin-top:12px}
        input[type=file]{display:none}
        .hint{color:var(--muted);font-size:13px}
        footer{margin-top:18px;color:var(--muted);font-size:13px}

        /* Styling baru untuk tombol ambil foto yang responsif */
        #capture {
            width: 100%;
            margin-top: 12px;
            padding: 15px;
            font-size: 1.2em;
        }
        #capture .material-symbols-outlined {
            vertical-align: middle;
            font-size: 1.5em;
        }

        /* Styling untuk deteksi tepi */
        .edge-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 80%;
            border: 2px dashed #06b6d4;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .edge-frame::before, .edge-frame::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #06b6d4;
        }
        .edge-frame::before { top: -2px; left: -2px; border-right: none; border-bottom: none; }
        .edge-frame::after { top: -2px; right: -2px; border-left: none; border-bottom: none; }
        .edge-frame .bottom-left::before { bottom: -2px; left: -2px; border-top: none; border-right: none; }
        .edge-frame .bottom-right::after { bottom: -2px; right: -2px; border-top: none; border-left: none; }

        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
            z-index: 20;
            display: none;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <header>
            <img src="" alt="" style="width:44px;height:44px;border-radius:8px;background:linear-gradient(90deg,#06b6d4,#7c3aed)">
            <div>
                <h1>Pesulap Scanner</h1>
                <div class="hint">Scan beberapa foto, export JPG, dan share (Web Share API jika tersedia)</div>
            </div>
        </header>

        <div class="controls">
            <label class="btn">
                Pilih Foto
                <input id="fileInput" type="file" accept="image/*" multiple>
            </label>

            <button id="startCam" class="btn secondary">Buka Kamera</button>
            <button id="exportJpg" class="btn" disabled>Export JPG</button>
            <button id="shareNow" class="btn" disabled>Share</button>
        </div>

        <div style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap">
            <div class="card">
                <div id="video-container">
                    <video id="video" autoplay playsinline muted></video>
                    <div id="edge-overlay" class="edge-frame" style="display:none;">
                        <div class="corner top-left"></div>
                        <div class="corner top-right"></div>
                        <div class="corner bottom-left"></div>
                        <div class="corner bottom-right"></div>
                    </div>
                    <div id="progress-overlay" class="progress-overlay">
                        Memproses foto...
                    </div>
                </div>
                <button id="capture" class="btn" disabled>
                    <span class="material-symbols-outlined">camera</span>
                    Ambil Foto
                </button>
                <div class="hint" style="margin-top:8px">Jika membuka di perangkat mobile, izinkan akses kamera. Untuk desktop, kamera tersedia jika device punya webcam.</div>
            </div>

            <div style="flex:1;min-width:280px">
                <div class="card">
                    <strong>Preview Foto</strong>
                    <div id="thumbGrid" class="grid"></div>
                    <div class="actions">
                        <button id="clearAll" class="btn secondary" disabled>Hapus Semua</button>
                    </div>
                </div>

                <div class="card" style="margin-top:12px">
                    <strong>Catatan</strong>
                    <ul>
                        <li>Export menghasilkan file JPG dan juga ZIP untuk unduhan massal.</li>
                        <li>Fitur Share menggunakan <code>navigator.share()</code> (tersedia di Chrome mobile & beberapa browser lain).</li>
                        <li>Kalau share gagal, gunakan tombol Export lalu bagikan manual ke Telegram/WhatsApp.</li>
                    </ul>
                </div>
            </div>
        </div>

        <footer>Created for you — gunakan di Chrome (HTTPS diperlukan untuk kamera & share).</footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
    <script>
        const fileInput = document.getElementById('fileInput')
        const thumbGrid = document.getElementById('thumbGrid')
        const startCamBtn = document.getElementById('startCam')
        const captureBtn = document.getElementById('capture')
        const exportBtn = document.getElementById('exportJpg')
        const shareBtn = document.getElementById('shareNow')
        const clearAllBtn = document.getElementById('clearAll')
        const video = document.getElementById('video')
        const edgeOverlay = document.getElementById('edge-overlay')
        const progressOverlay = document.getElementById('progress-overlay')

        let stream = null
        let images = []
        let cvReady = false;

        // Callback ketika OpenCV.js sudah siap
        function onOpenCvReady() {
            cvReady = true;
            console.log('OpenCV.js is ready.');
        }

        function playShutterSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'square';
            oscillator.frequency.value = 880;
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function updateUI(){
            thumbGrid.innerHTML = ''
            images.forEach((it, idx)=>{
                const div = document.createElement('div')
                div.className = 'thumb'
                div.innerHTML = `<img src="${it.dataUrl}" alt="img"><div class="meta">${it.name}</div>`
                const del = document.createElement('button')
                del.textContent = '✕'
                del.style.position='absolute';del.style.right='6px';del.style.top='6px';del.style.background='rgba(0,0,0,0.45)';del.style.border='0';del.style.color='#fff';del.style.borderRadius='6px';del.style.padding='2px 6px';
                del.onclick = ()=>{ images.splice(idx,1); updateUI(); }
                div.appendChild(del)
                thumbGrid.appendChild(div)
            })
            const has = images.length>0
            exportBtn.disabled = !has
            shareBtn.disabled = !has
            clearAllBtn.disabled = !has
            captureBtn.disabled = !stream
        }

        function readFilesList(fileList){
            Array.from(fileList).forEach((f, i)=>{
                const reader = new FileReader()
                reader.onload = e => {
                    const dataUrl = e.target.result
                    images.push({blob:f, name: f.name.replace(/\.[^.]+$/, '') + '.jpg', dataUrl})
                    updateUI()
                }
                reader.readAsDataURL(f)
            })
        }

        fileInput.addEventListener('change', e=> readFilesList(e.target.files))

        startCamBtn.addEventListener('click', async ()=>{
            if(stream){
                stream.getTracks().forEach(t=>t.stop()); stream=null; video.srcObject = null; startCamBtn.textContent='Buka Kamera'
                edgeOverlay.style.display = 'none';
                updateUI(); return
            }
            try{
                stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false})
                video.srcObject = stream
                startCamBtn.textContent='Tutup Kamera'
                captureBtn.disabled = false
                edgeOverlay.style.display = 'block';
            }catch(err){
                alert('Gagal mengakses kamera: '+err.message)
            }
        })

        // Logika Auto-Cropping
        captureBtn.addEventListener('click', async () => {
            if (!stream || !cvReady) return;
            playShutterSound();

            progressOverlay.style.display = 'flex';
            captureBtn.disabled = true;

            const w = video.videoWidth;
            const h = video.videoHeight;
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, w, h);

            try {
                // Konversi gambar ke format yang bisa diproses OpenCV
                const src = cv.imread(canvas);
                const dst = new cv.Mat();
                const gray = new cv.Mat();
                const blurred = new cv.Mat();
                const M = cv.Mat.zeros(2, 4, cv.CV_32FC1);
                const finalCanvas = document.createElement('canvas');
                
                // Pra-pemrosesan gambar
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                
                // Deteksi tepi (Canny Edge Detection)
                cv.Canny(blurred, dst, 75, 200, 3, false);

                // Cari kontur
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dst, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

                let largestContour = null;
                let maxArea = 0;

                // Cari kontur terbesar
                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt, false);
                    if (area > maxArea) {
                        const perimeter = cv.arcLength(cnt, true);
                        const approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * perimeter, true);
                        if (approx.size().height === 4) { // Cek apakah kontur memiliki 4 sudut
                            maxArea = area;
                            largestContour = approx;
                        }
                        approx.delete();
                    }
                    cnt.delete();
                }

                if (largestContour) {
                    // Mendapatkan 4 sudut dari kontur
                    const points = [
                        {x: largestContour.data32S[0], y: largestContour.data32S[1]},
                        {x: largestContour.data32S[2], y: largestContour.data32S[3]},
                        {x: largestContour.data32S[4], y: largestContour.data32S[5]},
                        {x: largestContour.data32S[6], y: largestContour.data32S[7]}
                    ];

                    // Sortir sudut-sudutnya (penting untuk koreksi perspektif)
                    points.sort((a, b) => a.y - b.y);
                    const [tl, tr, bl, br] = points[0].x < points[1].x ? [points[0], points[1]] : [points[1], points[0]];
                    const [blSorted, brSorted] = points[2].x < points[3].x ? [points[2], points[3]] : [points[3], points[2]];

                    // Persiapan untuk koreksi perspektif
                    let srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, brSorted.x, brSorted.y, blSorted.x, blSorted.y]);
                    let newWidth = Math.max(cv.norm(cv.matFromArray(1, 2, cv.CV_32FC2, [tr.x, tr.y, brSorted.x, brSorted.y])), cv.norm(cv.matFromArray(1, 2, cv.CV_32FC2, [tl.x, tl.y, blSorted.x, blSorted.y])));
                    let newHeight = Math.max(cv.norm(cv.matFromArray(1, 2, cv.CV_32FC2, [brSorted.x, brSorted.y, blSorted.x, blSorted.y])), cv.norm(cv.matFromArray(1, 2, cv.CV_32FC2, [tr.x, tr.y, tl.x, tl.y])));
                    let destPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, newWidth, 0, newWidth, newHeight, 0, newHeight]);

                    let M_final = cv.getPerspectiveTransform(srcPoints, destPoints);
                    let finalImage = new cv.Mat();
                    cv.warpPerspective(src, finalImage, M_final, new cv.Size(newWidth, newHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

                    // Tampilkan gambar yang sudah di-crop ke kanvas
                    finalCanvas.width = newWidth;
                    finalCanvas.height = newHeight;
                    cv.imshow(finalCanvas, finalImage);
                    
                    finalImage.delete();
                    M_final.delete();
                    srcPoints.delete();
                    destPoints.delete();

                } else {
                    // Jika tidak ada kontur yang terdeteksi, gunakan gambar asli
                    finalCanvas.width = w;
                    finalCanvas.height = h;
                    ctx.drawImage(video, 0, 0, w, h);
                }

                src.delete();
                dst.delete();
                gray.delete();
                blurred.delete();
                contours.delete();
                hierarchy.delete();
                if (largestContour) largestContour.delete();

                finalCanvas.toBlob(blob => {
                    const name = `scan_${Date.now()}.jpg`;
                    const reader = new FileReader();
                    reader.onload = e => {
                        images.push({blob, name, dataUrl: e.target.result});
                        updateUI();
                        progressOverlay.style.display = 'none';
                        captureBtn.disabled = false;
                    };
                    reader.readAsDataURL(blob);
                }, 'image/jpeg', 0.9);

            } catch (err) {
                console.error("Gagal memproses gambar:", err);
                alert("Gagal memproses gambar. Pastikan dokumen berada di area yang terang.");
                progressOverlay.style.display = 'none';
                captureBtn.disabled = false;
            }
        });

        clearAllBtn.addEventListener('click', ()=>{
            if(confirm('Hapus semua foto dari sesi ini?')){ images=[]; updateUI() }
        })

        exportBtn.addEventListener('click', async ()=>{
            if(images.length===0) return
            const blobs = await Promise.all(images.map(async (it)=> it.blob instanceof Blob ? {blob: it.blob, name: it.name} : {blob: await (await fetch(it.dataUrl)).blob(), name: it.name}))
            try{
                const zip = new JSZip()
                blobs.forEach(b => zip.file(b.name, b.blob))
                const zipBlob = await zip.generateAsync({type:'blob'})
                const url = URL.createObjectURL(zipBlob)
                const a = document.createElement('a')
                a.href = url
                a.download = 'scans_' + Date.now() + '.zip'
                document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url)
                alert('ZIP berhasil diunduh.')
            }catch(err){
                console.error(err)
            }
        })

        shareBtn.addEventListener('click', async ()=>{
            if(images.length===0) return
            const files = await Promise.all(images.map(async it=>{
                const blob = it.blob instanceof Blob ? it.blob : await (await fetch(it.dataUrl)).blob()
                return new File([blob], it.name, {type: 'image/jpeg'})
            }))
            if(navigator.canShare && navigator.canShare({files})){
                try{
                    await navigator.share({files, title:'Scan Photos', text:'Foto hasil scan'})
                    return
                }catch(err){ console.warn('Share failed', err) }
            }
            alert('Share langsung tidak tersedia di browser ini. Gunakan Export, lalu kirim manual ke WhatsApp/Telegram.')
        })

        updateUI()
    </script>
</body>
</html>
